# TIME MANAGER
from climaf.api import *
import os, copy, subprocess, shlex
from datetime import datetime
from shutil import copyfile
from getpass import getuser

# -- Si je veux choisir ma periode, et qu'elle soit la meme entre les TS et les climato
#    -> frequency='monthly', period='1980-2000'
# -- Si je veux utiliser les SE:
#    -> frequency='seasonal', clim_period='1980_1989'
# -- Si je veux utiliser les SE pour les climatos, et choisir ma periode pour les TS:
#    -> frequency='seasonal', clim_period='1980_1989', ts_period='full'
# -- Si je veux le dernier SE pour les climatos, et choisir ma periode pour les TS:
#    -> frequency='seasonal', clim_period='last', ts_period='full'
# -- Si je veux toute la periode pour les TS, et seulement une selection pour les climatos (ne pas tout utiliser)
#    -> frequency='monthly', clim_period='last_30Y', ts_period='full'
#    -> frequency='monthly', clim_period='1980_2005', ts_period='full'

# -- En amont du diag, il faut faire la difference entre diag 'clim' ou diag 'TS'


    
def base_variable_of_derived_variable(tested_variable, project='*'):
    ''' Returns one of the variables used to compute a derived variable '''
    project_derived_variables = copy.deepcopy(derived_variables['*'])
    if project in derived_variables: project_derived_variables.update(derived_variables[project])
    while tested_variable in project_derived_variables.keys():
        for elt in project_derived_variables[tested_variable]:
            if isinstance(elt,list):
                base_var = elt[0]
        tested_variable = base_var
    return tested_variable

from CM_atlas.time_manager import *

def period_manager_PMP_MG(models, diag='', diag_type='clim', testvar=None):
    Wmodels = period_for_diag_manager(copy.deepcopy(models), diag=diag)
    NewList_models = []
    for Wmodel in Wmodels:
        model = Wmodel.copy()
        if testvar:
            model.update(dict(variable=testvar))
        else:
            print '----> No testvar provided in period_manager_PMP_MG'
        #frequency_manager_for_diag_type(model, diag_type=diag_type)
        frequency_manager_for_diag(model, diag=diag_type)
        wmodel = get_period_manager(model)
        if isinstance(wmodel,dict):
            NewList_models.append(wmodel)
        if isinstance(wmodel,list):
            NewList_models = NewList_models + wmodel

    return NewList_models

def split_periods_in_models(models):
    import copy
    Wmodels = copy.deepcopy(models)
    New_models = []
    #
    for model in Wmodels:
        splitted_model = []
        if 'frequency' in model:
            if model['frequency'] in ['seasonal', 'annual_cycle']: wperiod = 'clim_period'
            if model['frequency'] in ['monthly']: wperiod = 'period'
            if isinstance(model[wperiod],list):
                for PRD in model[wperiod]:
                    wmodel = model.copy()
                    wmodel.update({wperiod:PRD})
                    splitted_model.append(wmodel)
                New_models = New_models + splitted_model
            else:
                New_models.append(model)
        else:
            print 'frequency is missing in model: ',model
    return New_models



def get_keys_for_PMP_MG(wmodel):
    ''' Works on a python dictionary that typically describes a dataset '''
    ''' in the C-ESM-EP datasets_setup.py.                              '''
    ''' Get the keys that are necessary to work with the PMP / MG       '''
    ''' These keys will be used to build the path the metrics results,  '''
    ''' the name of the netcdf climatology file taken as input by the   '''
    ''' PMP, or to provide the keys in the PMP so that the metrics      '''
    ''' metadata are provided.                                          '''
    Wmodel = wmodel.copy()
    if 'project' not in wmodel: Wmodel.update(dict(project='project_not_defined'))
    # -- Model
    if 'model' not in wmodel: Wmodel.update(dict(model='model_not_defined'))
    # -- Experiment
    experiment = 'experiment_not_defined'
    if 'experiment' not in wmodel: Wmodel.update(dict(experiment='experiment_not_defined'))
    # -- Simulation
    if 'simulation' not in wmodel: Wmodel.update(dict(simulation='simulation_not_defined'))
    # -- Period
    if wmodel['frequency'] in ['seasonal', 'annual_cycle']: wperiod = wmodel['clim_period']
    if wmodel['frequency'] in ['monthly']: wperiod = wmodel['period']
    period = str(wperiod)
    Wmodel.update(dict(period=period))
    # -- Variable
    if 'variable' not in wmodel: Wmodel.update(dict(variable='variable_not_defined'))
    # -- Login
    if 'login' not in wmodel: Wmodel.update(dict(login='login_not_defined'))
    return Wmodel
    

def build_metric_outpath(model, group, subdir=None, root_outpath=None):
    ''' Builds the typical output tree for the metrics  '''
    ''' Takes as input a python dictionary (dataset),   '''
    ''' a group of metrics (name in the mongo database) '''
    ''' and a sub-directory subdir.                     '''
    #
    if not root_outpath:
        from getpass import getuser
        if onCiclad: root_outpath = '/data/'+getuser()
        if atTGCC:   root_outpath = '${SCRATCHDIR}'
    if not subdir:
        from datetime import datetime
        subdir = datetime.today().strftime("%Y-%m-%d")
    #
    # -- 0/ Fill the keys with 'not provided' with get_keys_for_PMP_MG
    wmodel = get_keys_for_PMP_MG(model)
    #
    project =    wmodel['project']
    model =      wmodel['model']
    experiment = wmodel['experiment']
    simulation = wmodel['simulation']
    period =     wmodel['period']
    login =      wmodel['login']
    #
    # -- Prepare the output directory for the temporary netcdf files that will be used
    # -- to compute the metrics
    #
    return root_outpath + '/PMP_OUT/metrics_results/'+ subdir + '/raw/' + project+'_'+login+'_'+model+'_'+experiment+'_'+simulation+'_'+period+'_'+group
    

def build_input_climatology_filename(model):
    ''' Builds the name of an input climatology filename '''
    ''' Takes as input a python dictionary (dataset).    '''
    #
    # -- 0/ Fill the keys with 'not provided' with get_keys_for_PMP_MG
    wmodel = get_keys_for_PMP_MG(model)
    
    project =    wmodel['project']
    model =      wmodel['model']
    experiment = wmodel['experiment']
    simulation = wmodel['simulation']
    period =     wmodel['period']
    variable =   wmodel['variable']

    # -- Prepare the output directory for the temporary netcdf files that will be used
    # -- to compute the metrics
    return project+'_'+model+'_'+experiment+'_'+simulation+'_'+period+'_'+variable+'.nc'
    



dict_group = {
        'LMDZ_PCMDI':{
           'variables':['pr','prw','tas','uas','vas','psl','rlut','rsut','rlutcs','rsutcs','huss',
                        'ta_850','ta_200','ua_850','ua_200','va_850','va_200','zg_500','hus_850'
                        'rtnetcre','rstcre','rltcre',
                        'tauu','tauv'],
            'targetGrid':'2.5x2.5'
        },
        'NEMO_PCMDI':{
            'variables':['sos','tos','wfo','zos','mldpt'],
            'targetGrid':'2.5x2.5'
        },
        'NEMO_VertLevels':{
            'variables':['tod_50','tod_100','tod_500','tod_1000',
                        'sod_50','sod_100','sod_500','sod_1000'],
            'targetGrid':'2.5x2.5'
        },
        'PISCES_VertLevels':{
            'variables':['PO4_1000m'],
            'targetGrid':'2.5x2.5'
        },
        'ORCHIDEE_PCMDI':{
            'variables':['gpp'],
            'targetGrid':'2.5x2.5'
        }
    }

import re

def pysed(file, old_pattern, new_pattern):
    with open(file, "r") as sources:
        lines = sources.readlines()
    with open(file, "w") as sources:
        for line in lines:
            sources.write(re.sub(old_pattern, new_pattern, line))
    print 'Replaced old_pattern = '+old_pattern+' with new_pattern = '+new_pattern
    print 'in the file : ',file
    return ''


